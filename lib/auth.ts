import { NextAuthOptions } from 'next-auth'
import GoogleProvider from 'next-auth/providers/google'
import { queryOne, insert } from '@/lib/mysql'

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  session: {
    strategy: 'jwt',
  },
  callbacks: {
    async signIn({ user, account, profile }) {
      try {
        if (!user.email) {
          console.error('‚ùå Email nen√≠ k dispozici')
          return false
        }

        // Kontrola, zda u≈æivatel ji≈æ existuje v datab√°zi (podle emailu)
        const existingUser = await queryOne(
          'SELECT id FROM users WHERE email = ?',
          [user.email]
        )

        if (!existingUser) {
          // Vytvo≈ôen√≠ nov√©ho u≈æivatele v datab√°zi (jen pokud neexistuje)
          const userId = user.id || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
          
          try {
            await insert(
              `INSERT INTO users (id, name, email, image, createdAt, updatedAt, isVerified) 
               VALUES (?, ?, ?, ?, NOW(), NOW(), ?)`,
              [
                userId,
                user.name,
                user.email,
                user.image,
                account?.provider === 'google' ? true : false
              ]
            )
            // Nastavit user.id pro JWT callback
            ;(user as any).id = userId
            console.log('‚úÖ Nov√Ω u≈æivatel vytvo≈ôen v datab√°zi:', user.email)
          } catch (insertError: any) {
            // Pokud je to duplicitn√≠ ID, zkusit naƒç√≠st existuj√≠c√≠ho u≈æivatele podle emailu
            if (insertError.code === 'ER_DUP_ENTRY') {
              const retryUser = await queryOne(
                'SELECT id FROM users WHERE email = ?',
                [user.email]
              )
              if (retryUser) {
                ;(user as any).id = retryUser.id
                console.log('üë§ U≈æivatel nalezen po konfliktu ID:', user.email)
              } else {
                console.error('‚ùå Duplicitn√≠ ID a u≈æivatel nebyl nalezen')
                return false
              }
            } else {
              throw insertError
            }
          }
        } else {
          // U≈æivatel existuje - pou≈æ√≠t jeho ID
          ;(user as any).id = existingUser.id
          console.log('üë§ U≈æivatel ji≈æ existuje v datab√°zi:', user.email)
        }

        return true
      } catch (error) {
        console.error('‚ùå Chyba p≈ôi p≈ôihl√°≈°en√≠ u≈æivatele:', error)
        return false // Nepovolit p≈ôihl√°≈°en√≠ p≈ôi chybƒõ
      }
    },
    async jwt({ token, user }) {
      if (user) {
        token.id = (user as any).id
      }
      return token
    },
    async session({ session, token }) {
      if (token && token.id) {
        (session.user as any).id = token.id as string
      }
      return session
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
  secret: process.env.NEXTAUTH_SECRET,
}